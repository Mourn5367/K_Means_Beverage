<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means ìŒë£Œ êµ°ì§‘í™”</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        select, input[type="range"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #ddd;
            border: none;
            border-radius: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }

        .k-value-display {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            text-align: center;
            margin-top: 5px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            min-height: 600px;
        }

        .sidebar {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .cluster-info {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }

        .cluster-title {
            font-weight: bold;
            font-size: 1.1em;
            color: #333;
            margin-bottom: 10px;
        }

        .cluster-stat {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 0.9em;
        }

        .input-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .input-section h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .feature-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #555;
        }

        .input-group input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-predict {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn-predict:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .prediction-result {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            display: none;
        }

        .prediction-result.show {
            display: block;
        }

        .similar-beverages {
            margin-top: 10px;
        }

        .beverage-item {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 8px;
            border-left: 3px solid #667eea;
        }

        .beverage-name {
            font-weight: 600;
            color: #333;
        }

        .beverage-details {
            font-size: 0.85em;
            color: #666;
            margin-top: 3px;
        }

        /* ëª¨ë‹¬ ìŠ¤í¬ë¡¤ë°” ìˆ¨ê¸°ê¸° */
        div[style*="overflow-y: auto"]::-webkit-scrollbar {
            display: none;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
            display: none;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .insights-detail {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .feature-table {
            width: 100%;
            font-size: 0.85em;
            margin-top: 10px;
        }

        .feature-table td {
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .feature-table td:first-child {
            font-weight: 600;
            color: #555;
        }

        .representative-list {
            margin-top: 10px;
        }

        .rep-item {
            padding: 5px 0;
            font-size: 0.85em;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¹ K-Means ìŒë£Œ êµ°ì§‘í™” â˜•ï¸</h1>
        <p class="subtitle">Kê°’ì„ ì¡°ì •í•˜ì—¬ êµ°ì§‘ì„ í™•ì¸í•˜ê³  ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì—¬ ì˜ˆì¸¡í•´ë³´ì„¸ìš”.<br>ëª¨ë“  ì„±ë¶„ê°’ì€ 100ml(g)ê¸°ì¤€ì…ë‹ˆë‹¤.</p>

        <div class="controls">
            <div class="control-group">
                <label for="beverageType">ìŒë£Œ íƒ€ì…</label>
                <select id="beverageType" onchange="autoCluster()">
                    <option value="caffeine">ì¹´í˜ì¸ ìŒë£Œ (1,225ê°œ)</option>
                    <option value="noncaffeine">ë…¼ì¹´í˜ì¸ ìŒë£Œ (710ê°œ)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="kValue">K ê°’ (êµ°ì§‘ ìˆ˜)</label>
                <input type="range" id="kValue" min="3" max="11" value="3" step="2" oninput="updateKValue()">
                <div class="k-value-display">K = <span id="kValueDisplay">3</span></div>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>ë¶„ì„ ì¤‘...</div>
        </div>

        <div class="main-content">
            <div class="chart-container">
                <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                    <div style="flex: 1;">
                        <label style="font-size: 0.9em; color: #666;">Xì¶•:</label>
                        <select id="xAxisSelect" onchange="updateScatterPlot()" style="width: 100%; padding: 5px; border: 2px solid #ddd; border-radius: 5px;">
                        </select>
                    </div>
                    <div style="flex: 1;">
                        <label style="font-size: 0.9em; color: #666;">Yì¶•:</label>
                        <select id="yAxisSelect" onchange="updateScatterPlot()" style="width: 100%; padding: 5px; border: 2px solid #ddd; border-radius: 5px;">
                        </select>
                    </div>
                </div>
                <div id="scatterPlot"></div>
            </div>

            <div class="sidebar">
                <h3>êµ°ì§‘ ì •ë³´</h3>
                <div id="clusterInfo"></div>
            </div>
        </div>

        <div class="input-section">
            <h3>ğŸ” ìœ ì‚¬ ìŒë£Œ ì°¾ê¸°</h3>
            <p style="color: #666; margin-bottom: 15px;">
                ì˜ì–‘ì†Œ ê°’ì„ ì…ë ¥í•˜ì—¬ ìœ ì‚¬í•œ ìŒë£Œë¥¼ ì°¾ì•„ë³´ì„¸ìš”<br>
                <small style="color: #999;">ğŸ’¡ ì¼ë¶€ë§Œ ì…ë ¥í•´ë„ ë©ë‹ˆë‹¤. ì…ë ¥í•˜ì§€ ì•Šì€ ê°’ì€ 0ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.</small>
            </p>

            <div class="feature-inputs" id="featureInputs"></div>

            <button class="btn-predict" onclick="predictSimilar()">ìœ ì‚¬ ìŒë£Œ ì°¾ê¸°</button>

            <div class="prediction-result" id="predictionResult"></div>
        </div>
    </div>

    <script>
        // í˜„ì¬ í˜ì´ì§€ì˜ í˜¸ìŠ¤íŠ¸ì™€ í¬íŠ¸ë¥¼ ìë™ìœ¼ë¡œ ì‚¬ìš©
        const API_BASE = `${window.location.protocol}//${window.location.host}/api/v1`;
        let currentData = null;
        let currentInsightsData = null;
        let debounceTimer = null;
        let previousXAxisIdx = 0;
        let previousYAxisIdx = 1;

        // Kê°’ ì—…ë°ì´íŠ¸ ë° ìë™ êµ°ì§‘í™”
        function updateKValue() {
            const k = document.getElementById('kValue').value;
            document.getElementById('kValueDisplay').textContent = k;

            // ë””ë°”ìš´ìŠ¤: ìŠ¬ë¼ì´ë” ì¡°ì • í›„ 500ms ëŒ€ê¸°
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(autoCluster, 500);
        }

        // ìë™ êµ°ì§‘í™”
        async function autoCluster() {
            const beverageType = document.getElementById('beverageType').value;
            const k = parseInt(document.getElementById('kValue').value);

            setLoading(true);

            try {
                const response = await fetch(`${API_BASE}/cluster`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        beverage_type: beverageType,
                        k: k,
                        force_retrain: false
                    })
                });

                if (!response.ok) throw new Error('êµ°ì§‘í™” ì‹¤íŒ¨');

                const data = await response.json();
                currentData = data;

                // ì¸ì‚¬ì´íŠ¸ ê°€ì ¸ì˜¤ê¸°
                const insightsResponse = await fetch(`${API_BASE}/insights/${beverageType}/${k}`);
                const insightsData = await insightsResponse.json();
                currentInsightsData = insightsData;

                // ì¶• ì„ íƒ ì˜µì…˜ ì„¤ì •
                setupAxisSelectors(data.features_used);

                displayScatterPlot(data, insightsData);
                displayClusterInfo(insightsData);
                setupFeatureInputs(data.beverage_type);

            } catch (error) {
                console.error('Error:', error);
            } finally {
                setLoading(false);
            }
        }

        // ì¶• ì„ íƒ ì˜µì…˜ ì„¤ì •
        function setupAxisSelectors(features) {
            const xSelect = document.getElementById('xAxisSelect');
            const ySelect = document.getElementById('yAxisSelect');

            xSelect.innerHTML = features.map((f, i) =>
                `<option value="${i}" ${i === 0 ? 'selected' : ''}>${f}</option>`
            ).join('');

            ySelect.innerHTML = features.map((f, i) =>
                `<option value="${i}" ${i === 1 ? 'selected' : ''}>${f}</option>`
            ).join('');

            // ì´ˆê¸° ê°’ ì €ì¥
            previousXAxisIdx = 0;
            previousYAxisIdx = 1;
        }

        // ì‚°ì ë„ ì—…ë°ì´íŠ¸ (ì¶• ë³€ê²½ ì‹œ)
        function updateScatterPlot() {
            const xAxisIdx = parseInt(document.getElementById('xAxisSelect').value);
            const yAxisIdx = parseInt(document.getElementById('yAxisSelect').value);

            // Xì¶•ê³¼ Yì¶•ì´ ê°™ìœ¼ë©´ ê²½ê³ í•˜ê³  ì´ì „ ê°’ìœ¼ë¡œ ë˜ëŒë¦¼
            if (xAxisIdx === yAxisIdx) {
                alert('Xì¶•ê³¼ Yì¶•ì€ ì„œë¡œ ë‹¤ë¥¸ ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤.');
                // ì´ì „ ê°’ìœ¼ë¡œ ë˜ëŒë¦¬ê¸°
                document.getElementById('xAxisSelect').value = previousXAxisIdx;
                document.getElementById('yAxisSelect').value = previousYAxisIdx;
                return;
            }

            // í˜„ì¬ ê°’ì„ ì´ì „ ê°’ìœ¼ë¡œ ì €ì¥
            previousXAxisIdx = xAxisIdx;
            previousYAxisIdx = yAxisIdx;

            if (currentData && currentInsightsData) {
                displayScatterPlot(currentData, currentInsightsData);
            }
        }

        // ì‚°ì ë„ í‘œì‹œ (Plotly)
        async function displayScatterPlot(clusterData, insightsData) {
            const beverageType = clusterData.beverage_type;
            const k = clusterData.k;
            const features = clusterData.features_used;
            const dataPoints = clusterData.data_points || [];

            // ì„ íƒëœ ì¶• ê°€ì ¸ì˜¤ê¸°
            const xAxisIdx = parseInt(document.getElementById('xAxisSelect').value) || 0;
            const yAxisIdx = parseInt(document.getElementById('yAxisSelect').value) || 1;

            // Xì¶•ê³¼ Yì¶•ì´ ê°™ìœ¼ë©´ ì°¨íŠ¸ë¥¼ ê·¸ë¦¬ì§€ ì•ŠìŒ
            if (xAxisIdx === yAxisIdx) {
                alert('Xì¶•ê³¼ Yì¶•ì€ ì„œë¡œ ë‹¤ë¥¸ ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }

            // ê° êµ°ì§‘ë³„ ë°ì´í„° ì¤€ë¹„
            const traces = [];
            const colors = ['#667eea', '#f093fb', '#4facfe', '#43e97b', '#fa709a', '#fee140', '#30cfd0', '#a8edea', '#ff6b6b', '#c471ed'];

            for (let i = 0; i < k; i++) {
                // í•´ë‹¹ í´ëŸ¬ìŠ¤í„°ì˜ ë°ì´í„° í¬ì¸íŠ¸ í•„í„°ë§
                const clusterPoints = dataPoints.filter(p => p.cluster === i);

                // ì„ íƒëœ í”¼ì³ë¥¼ x, y ì¢Œí‘œë¡œ ì‚¬ìš©
                const x = clusterPoints.map(p => p[features[xAxisIdx]]);
                const y = clusterPoints.map(p => p[features[yAxisIdx]]);

                // hover í…ìŠ¤íŠ¸ì— ì˜ì–‘ ì„±ë¶„ í¬í•¨
                const text = clusterPoints.map(p => {
                    let info = `<b>${p.ì‹í’ˆëª…}</b><br>`;
                    info += `ë¶„ë¥˜: ${p.ëŒ€í‘œì‹í’ˆëª…}<br>`;
                    info += `ì œì¡°ì‚¬: ${p.ì—…ì²´ëª…}<br>`;
                    info += `<br><b>[ì˜ì–‘ ì„±ë¶„]</b><br>`;
                    features.forEach(f => {
                        info += `${f}: ${p[f] !== undefined ? p[f].toFixed(1) : 'N/A'}<br>`;
                    });
                    return info;
                });

                // í´ëŸ¬ìŠ¤í„° ì´ë¦„ ì‚¬ìš©
                const clusterName = insightsData.clusters[i].name;

                traces.push({
                    x: x,
                    y: y,
                    mode: 'markers',
                    type: 'scatter',
                    name: clusterName,
                    text: text,
                    hoverinfo: 'text',
                    marker: {
                        size: 8,
                        color: colors[i],
                        opacity: 0.6,
                        line: {
                            color: 'white',
                            width: 1
                        }
                    },
                    customdata: Array(clusterPoints.length).fill(i)
                });
            }

            const layout = {
                title: `${beverageType === 'caffeine' ? 'ì¹´í˜ì¸' : 'ë…¼ì¹´í˜ì¸'} ìŒë£Œ êµ°ì§‘ ë¶„ì„ (K=${k})`,
                xaxis: { title: features[xAxisIdx] },
                yaxis: { title: features[yAxisIdx] },
                hovermode: 'closest',
                showlegend: true,
                height: 550
            };

            const config = {
                responsive: true,
                displayModeBar: true
            };

            Plotly.newPlot('scatterPlot', traces, layout, config);

            // í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('scatterPlot').on('plotly_click', function(data) {
                const clusterId = data.points[0].customdata;
                showClusterDetail(insightsData.clusters[clusterId], beverageType);
            });
        }

        // êµ°ì§‘ ì •ë³´ í‘œì‹œ
        function displayClusterInfo(insightsData) {
            const beverageType = insightsData.beverage_type;
            const html = insightsData.clusters.map(cluster => `
                <div class="cluster-info" onclick="showClusterDetail(${JSON.stringify(cluster).replace(/"/g, '&quot;')}, '${beverageType}')">
                    <div class="cluster-title">${cluster.name}</div>
                    <div class="cluster-stat">
                        <span>í¬ê¸°</span>
                        <strong>${cluster.size}ê°œ (${cluster.percentage.toFixed(1)}%)</strong>
                    </div>
                    <div class="cluster-stat">
                        <span>ëŒ€í‘œ ì‹í’ˆ</span>
                        <strong>${cluster.representative_types[0]?.name || 'N/A'}</strong>
                    </div>
                </div>
            `).join('');

            document.getElementById('clusterInfo').innerHTML = html;
        }

        // êµ°ì§‘ ìƒì„¸ ì •ë³´ ëª¨ë‹¬
        function showClusterDetail(cluster, beverageType) {
            const beverageTypeText = beverageType === 'caffeine' ? 'ì¹´í˜ì¸ ìŒë£Œ' : 'ë…¼ì¹´í˜ì¸ ìŒë£Œ';
        let characteristics;

        if (cluster.characteristics.length === 0) {
            characteristics = `<li style="color:#999;">ìœ ì˜ë¯¸í•œ íŠ¹ì§•ì„ ë°œê²¬í•  ìˆ˜ ì—†ì—ˆìŠµë‹ˆë‹¤.</li>`;
        } else {
            characteristics = cluster.characteristics.map(c => {
                let color = '';

                if (c.includes("ì´ìƒ")) color = '#ff6b6b';
                if (c.includes("ì´í•˜")) color = '#667eea';

                const highlighted = c.replace(
                    /(\d+(\.\d+)?%)\s*(ì´ìƒ|ì´í•˜)/g,
                    `<span style="color:${color}; font-weight:600;">$1 $3</span>`
                );

                return `<li>${highlighted}</li>`;
            }).join('');
        }
                        
            const representatives = cluster.representative_types.slice(0, 5).map(r =>
                `<div class="rep-item">â–ª ${r.name}: ${r.count}ê°œ (${r.percentage.toFixed(1)}%)</div>`
            ).join('');

            const samples = cluster.sample_beverages.slice(0, 5).map(s => {
                let nutritionInfo = '';
                if (s.features) {
                    nutritionInfo = '<br><small style="color: #888;">';
                    Object.entries(s.features).forEach(([key, value]) => {
                        nutritionInfo += `${key}: ${value.toFixed(1)} | `;
                    });
                    nutritionInfo = nutritionInfo.slice(0, -3) + '</small>';
                }
                return `<div class="beverage-item">
                    <div class="beverage-name">${s.ì‹í’ˆëª…}</div>
                    <div class="beverage-details">${s.ì—…ì²´ëª…} | ${s.ëŒ€í‘œì‹í’ˆëª…}${nutritionInfo}</div>
                </div>`;
            }).join('');

            // ì˜ì–‘ ì„±ë¶„ë³„ ë¶„í¬ ì°¨íŠ¸ ID ìƒì„±
            const modalId = 'modal_' + Date.now();
            const featureCharts = Object.keys(cluster.feature_statistics).map((feature, idx) =>
                `<div id="${modalId}_chart_${idx}" style="width: 100%; height: 120px; margin: 10px 0;"></div>`
            ).join('');

            const modal = `
                <div id="${modalId}" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 1000; display: flex; align-items: center; justify-content: center;" onclick="this.remove()">
                    <div style="background: white; border-radius: 15px; padding: 30px; max-width: 800px; max-height: 85vh; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none;" onclick="event.stopPropagation()">
                        <h2 style="margin-bottom: 20px;">${cluster.name}</h2>
                        <p style="color: #666; margin-bottom: 15px;">${beverageTypeText} ì¤‘ ${cluster.size}ê°œ (${cluster.percentage.toFixed(1)}%)</p>

                        <h3 style="margin-top: 20px; margin-bottom: 10px;">ì˜ì–‘ ì„±ë¶„ ë¶„í¬</h3>

                        <!-- ë²”ë¡€ -->
                        <div style="display: flex; gap: 20px; margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 0.9em;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 30px; height: 3px; background: rgba(150, 150, 150, 0.8);"></div>
                                <span>ì „ì²´ ìŒë£Œ ë¶„í¬</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 30px; height: 3px; background: #667eea; border-top: 3px dashed #667eea;"></div>
                                <span style="color: #667eea; font-weight: 600;">êµ°ì§‘ í‰ê· </span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 30px; height: 3px; background: #ff6b6b; border-top: 3px dotted #ff6b6b;"></div>
                                <span style="color: #ff6b6b;">ì „ì²´ í‰ê· </span>
                            </div>
                        </div>

                        ${featureCharts}

                        <h3 style="margin-top: 20px; margin-bottom: 10px;">ì£¼ìš” íŠ¹ì§•</h3>
                        <ul style="padding-left: 20px; color: #555;">${characteristics}</ul>

                        <h3 style="margin-top: 20px; margin-bottom: 10px;">ëŒ€í‘œ ì‹í’ˆëª…</h3>
                        ${representatives}

                        <h3 style="margin-top: 20px; margin-bottom: 10px;">ëŒ€í‘œ ìŒë£Œ</h3>
                        ${samples}

                        <button onclick="this.closest('div[style*=fixed]').remove()" style="margin-top: 20px; width: 100%; padding: 10px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer;">ë‹«ê¸°</button>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modal);

            // ì°¨íŠ¸ ê·¸ë¦¬ê¸°
            drawFeatureDistributions(cluster, modalId);
        }

        // ì˜ì–‘ ì„±ë¶„ ë¶„í¬ ì°¨íŠ¸ ê·¸ë¦¬ê¸°
        async function drawFeatureDistributions(cluster, modalId) {
            const features = Object.keys(cluster.feature_statistics);

            for (let idx = 0; idx < features.length; idx++) {
                const feature = features[idx];
                const stats = cluster.feature_statistics[feature];
                const clusterMean = stats.mean;

                // ì „ì²´ ë°ì´í„°ì˜ í†µê³„ ê°€ì ¸ì˜¤ê¸° (currentInsightsData.global_statistics ì‚¬ìš©)
                const globalStats = currentInsightsData.global_statistics.feature_ranges[feature];
                const globalMin = globalStats.min;
                const globalMax = globalStats.max;
                const globalMean = globalStats.mean;

                // ì •ê·œë¶„í¬ ê³¡ì„  ìƒì„±
                const x = [];
                const y = [];
                const range = globalMax - globalMin;
                const std = range / 6; // ëŒ€ëµì ì¸ í‘œì¤€í¸ì°¨

                for (let i = 0; i <= 100; i++) {
                    const value = globalMin + (range * i / 100);
                    x.push(value);
                    // ê°„ë‹¨í•œ ì •ê·œë¶„í¬ ê·¼ì‚¬
                    const z = (value - globalMean) / std;
                    const density = Math.exp(-0.5 * z * z) / (std * Math.sqrt(2 * Math.PI));
                    y.push(density);
                }

                // ì „ì²´ ë¶„í¬ íŠ¸ë ˆì´ìŠ¤
                const distributionTrace = {
                    x: x,
                    y: y,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tozeroy',
                    fillcolor: 'rgba(200, 200, 200, 0.3)',
                    line: { color: 'rgba(150, 150, 150, 0.8)', width: 2 },
                    name: 'ì „ì²´ ìŒë£Œ ë¶„í¬',
                    hoverinfo: 'text',
                    showlegend: false
                };
        
                const zCluster = (clusterMean - globalMean) / std;
                const clusterY = Math.exp(-0.5 * zCluster * zCluster) / (std * Math.sqrt(2 * Math.PI));
                
                const zGlobal = (globalMean - globalMean) / std;
                const globalY = Math.exp(-0.5 * zGlobal * zGlobal) / (std * Math.sqrt(2 * Math.PI));

                const maxDensity = Math.max(...y);
                const minHeight = maxDensity * 0.2;

                const clusterYVisible = Math.max(clusterY, minHeight);
                const globalYVisible = Math.max(globalY, minHeight);
        
                // í´ëŸ¬ìŠ¤í„° í‰ê·  ìœ„ì¹˜ í‘œì‹œ
                const clusterTrace = {
                    x: [clusterMean, clusterMean],
                    y: [0, clusterYVisible],
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#667eea', width: 3},
                    name: 'êµ°ì§‘ í‰ê· ',
                    hoverinfo: 'text',
                    hovertext: `êµ°ì§‘ í‰ê· : ${clusterMean.toFixed(1)}<br>ì „ì²´ í‰ê· : ${globalMean.toFixed(1)}`,
                    showlegend: false
                };

                // ì „ì²´ í‰ê·  ìœ„ì¹˜ í‘œì‹œ
                const globalMeanTrace = {
                    x: [globalMean, globalMean],
                    y: [0, globalYVisible],
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#ff6b6b', width: 3 },
                    name: 'ì „ì²´ í‰ê· ',
                    hoverinfo: 'text',
                    hovertext: `ì „ì²´ í‰ê· : ${globalMean.toFixed(1)}<br>êµ°ì§‘ í‰ê· : ${clusterMean.toFixed(1)}`,
                    showlegend: false
                };

                const layout = {
                    title: {
                        text: feature.split('(')[0], // ë‹¨ìœ„ ì œê±°
                        font: { size: 14, weight: 600 }
                    },
                    xaxis: {
                        title: '',
                        showgrid: false,
                        fixedrange: true  // ì¤Œ/íŒ¬ ë¹„í™œì„±í™”
                    },
                    yaxis: {
                        title: '',
                        showticklabels: false,
                        showgrid: false,
                        fixedrange: true  // ì¤Œ/íŒ¬ ë¹„í™œì„±í™”
                    },
                    showlegend: false,
                    margin: { l: 40, r: 20, t: 40, b: 30 },
                    height: 120,
                    hovermode: 'closest'
                };

                const config = {
                    displayModeBar: false,
                    responsive: true,
                    staticPlot: false,  // í˜¸ë²„ëŠ” ê°€ëŠ¥í•˜ë„ë¡
                    scrollZoom: false,
                    doubleClick: false,
                    editable: false
                };

                Plotly.newPlot(`${modalId}_chart_${idx}`, [distributionTrace, clusterTrace, globalMeanTrace], layout, config);
            }
        }

        // í”¼ì³ ì…ë ¥ í•„ë“œ ì„¤ì •
        function setupFeatureInputs(beverageType) {
            const features = beverageType === 'caffeine'
                ? ['ì—ë„ˆì§€(kcal)', 'ë‹¨ë°±ì§ˆ(g)', 'ë‹¹ë¥˜(g)', 'ë‚˜íŠ¸ë¥¨(mg)', 'í¬í™”ì§€ë°©ì‚°(g)', 'ì¹´í˜ì¸(mg)']
                : ['ì—ë„ˆì§€(kcal)', 'ë‹¨ë°±ì§ˆ(g)', 'ë‹¹ë¥˜(g)', 'ë‚˜íŠ¸ë¥¨(mg)', 'í¬í™”ì§€ë°©ì‚°(g)'];

            const html = features.map(f => `
                <div class="input-group">
                    <label>${f} <small style="color: #999;">(ì„ íƒ)</small></label>
                    <input type="number" id="input_${f}" placeholder="ë¹„ì›Œë‘ë©´ 0 ì‚¬ìš©" step="0.1">
                </div>
            `).join('');

            document.getElementById('featureInputs').innerHTML = html;
        }

        // ìœ ì‚¬ ìŒë£Œ ì˜ˆì¸¡
        async function predictSimilar() {
            const beverageType = document.getElementById('beverageType').value;
            const k = parseInt(document.getElementById('kValue').value);

            const features = beverageType === 'caffeine'
                ? ['ì—ë„ˆì§€(kcal)', 'ë‹¨ë°±ì§ˆ(g)', 'ë‹¹ë¥˜(g)', 'ë‚˜íŠ¸ë¥¨(mg)', 'í¬í™”ì§€ë°©ì‚°(g)', 'ì¹´í˜ì¸(mg)']
                : ['ì—ë„ˆì§€(kcal)', 'ë‹¨ë°±ì§ˆ(g)', 'ë‹¹ë¥˜(g)', 'ë‚˜íŠ¸ë¥¨(mg)', 'í¬í™”ì§€ë°©ì‚°(g)'];

            const featuresDict = {};
            features.forEach(f => {
                const value = document.getElementById(`input_${f}`).value;
                // ë¹ˆ ë¬¸ìì—´ì´ë©´ 0, ê·¸ ì™¸ì—ëŠ” ì…ë ¥ëœ ìˆ«ì ì‚¬ìš©
                featuresDict[f] = value === '' ? 0 : parseFloat(value);
            });

            setLoading(true);

            try {
                const response = await fetch(`${API_BASE}/predict/similar`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        beverage_type: beverageType,
                        k: k,
                        features: featuresDict,
                        n_neighbors: 5,
                        search_scope: 'predicted_cluster'
                    })
                });

                if (!response.ok) throw new Error('ì˜ˆì¸¡ ì‹¤íŒ¨');

                const data = await response.json();
                displayPredictionResult(data);

            } catch (error) {
                alert('ì˜ˆì¸¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            } finally {
                setLoading(false);
            }
        }

        // ì˜ˆì¸¡ ê²°ê³¼ í‘œì‹œ
        function displayPredictionResult(data) {
            const similarHtml = data.similar_beverages.map(b => {
                let nutritionInfo = '<br><small style="color: #888;">';
                Object.entries(b.features).forEach(([key, value]) => {
                    nutritionInfo += `${key}: ${value.toFixed(1)} | `;
                });
                nutritionInfo = nutritionInfo.slice(0, -3) + '</small>';

                return `<div class="beverage-item">
                    <div class="beverage-name">${b.rank}. ${b.beverage_name}</div>
                    <div class="beverage-details">
                        ${b.company} | ${b.food_type} | ìœ ì‚¬ë„: ${(b.similarity_score * 100).toFixed(1)}%
                        ${nutritionInfo}
                    </div>
                </div>`;
            }).join('');

            // í´ëŸ¬ìŠ¤í„° ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
            let clusterName = `Cluster ${data.predicted_cluster}`;
            if (currentInsightsData && currentInsightsData.clusters[data.predicted_cluster]) {
                clusterName = currentInsightsData.clusters[data.predicted_cluster].name;
            }

            const html = `
                <h4 style="margin-bottom: 10px;">ì˜ˆì¸¡ êµ°ì§‘: ${clusterName}</h4>
                <p style="color: #666; font-size: 0.9em; margin-bottom: 10px;">
                    ${data.search_summary.total_searched}ê°œ ìŒë£Œ ì¤‘ ìœ ì‚¬í•œ ìŒë£Œ ${data.similar_beverages.length}ê°œ
                </p>
                <div class="similar-beverages">${similarHtml}</div>
            `;

            const resultDiv = document.getElementById('predictionResult');
            resultDiv.innerHTML = html;
            resultDiv.classList.add('show');
        }

        // ë¡œë”© í‘œì‹œ
        function setLoading(show) {
            document.getElementById('loading').classList.toggle('show', show);
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ì‹¤í–‰
        window.addEventListener('load', () => {
            setTimeout(autoCluster, 500);
        });
    </script>
</body>
</html>
